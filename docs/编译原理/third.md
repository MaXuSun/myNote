## 词法分析

### 正则表达式
1. RE:一种用来描述**正则语言**的**更紧凑**的表示方法
2. 正则表达式可以由较小的增则表达式
3. 正则表达式的定义：
    1. 
4. 正则表达式的代数定律
5. 正则文法与正则表达式等价


### 正则定义
1. 定义：给一些RE命名，并在之后的RE中像使用字母表中的符号一样使用这些名字。
2. C语言中的一些正则定义

### 有穷自动机(FA)
1. 定义
2. 转换图
3. FA定义(接受)的语言
4. 最长子串匹配原则

### 有穷自动机的分类
1. 确定的有穷自动机(DFA)
2. 非确定的有穷自动机(NFA)
3. DFA和NFA的等价性
4. 正则表达式 $\Leftrightarrow$ FA $\Leftrightarrow$ 正则文法
5. 带有"$\epsilon-$边"的NFA
6. 带有"$\epsilon-$边"的NFA和不带有"$\epsilon-$边"的NFA等价
7. DFA的算法实现
    1. 输入：以文件结束符eof结尾的字符串**x**,DFAD的开始状态$s_0$,接收状态集**F**,转换函数**move**
    2. 输出：如果D接收x,则回答"yes",否则回答"no"。
    3. 方法：将下述算法应用于输入串**x**。
    ```
    s = $s_0$;
    c = nextChar();
    while (c!=eof){
        s = move(s,c);  //表示从状态s出发,沿着标记为c的边所能到达的状态
        c = nextChar(); //返回输入串**x**的下一个符号
    }
    if(s在F中) return "yes";
    else return "no";
    ```

### 从正则表达式到DFA的转换
直接构造较为麻烦,所以从RE $\rightarrow$ NFA $\rightarrow$ DFA
1. 根据RE构造NFA
    1. $\epsilon$对应的NFA
    2. 字母表$\Sigma$中符号**a**对应的NFA
    3. r = $r_1r_2$对应的NFA
    4. r = $r_1$|$r_2$对应的NFA
    5. r = $(r_1)_*$对应的NFA

### 从NFA到DFA的转换
DFA的每个状态都是一个由NFA中的状态构成的**集合**,即**NFA状态集合的一个子集**
1. NFA转到DFA的例子
2. 带有$\epsilon-$边的NFA到DFA的转换
3. 子集构造法(subset construction)
    1. 输入：NFA N
    2. 输出：接收同样语言的DFA D
    3. 方法：一开始,$\epsilon$-

### 识别单词的DFA
1. 标识符的正则定义
    1. 标识符的正则定义
        * digit $\rightarrow$ 0|1|……|9
        * letter_ $\rightarrow$ A|B|……|Z|a|b|……|z|_
        * id $\rightarrow$ letter_(letter_|digit)
2. 识别无符号数的DFA
    1. digit $\rightarrow$ 0|1|……|9
    2. digits $\rightarrow$ digit $digit^*$
3. 识别各进制无符号整数的DFA

4. 识别注释的DFA

5. (整合)识别Token的DFA

### 词法分析阶段的错误处理
1. 词法分析阶段可检测错误的类型
    1. 单词拼写错误
    2. 非法字符
2. 词法错误检测
    * 如果当前状态与当前输入符号在转换表对应项中的信息为空,则报错,调用错误处理程序。
3. 错误处理方法
    1. 查找已扫描字符串中最后一个对应于某终态的字符
        * 如果找到了，将该字符与其前面的字符识别成一个单词。然后将输入指针退回到该字符，扫描器重新回到初始状态，继续识别下一个单词。
        * 如果没有找到，则确定出错，采用错误恢复策略。
4. 错误恢复策略
    1. 最简单的错误恢复策略:**恐慌模式(panic mode)**恢复
        * 从剩余的输入中不断剔除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符为止。
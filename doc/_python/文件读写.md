## 主要是python中文件读写的问题

### 读写模式

| 模式 | 描述 |
|:-:|:-:|
| t | 文本模式 (默认)。 |
|x|写模式，新建一个文件，如果该文件已存在则会报错。|
|b|二进制模式。|
|+|打开一个文件进行更新(可读可写)。|
|U|通用换行模式（不推荐）。|
|r|以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。|
|rb|以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。|
|r+|打开一个文件用于读写。文件指针将会放在文件的开头。|
|rb+|以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。|
|w|打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。|
|wb|以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新件。一般用于非文本文件如图片等。|
|w+|打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。|
|wb+|以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新件。一般用于非文本文件如图片等。|
|a|打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在创建新文件进行写入。|
|ab|以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如该文件不存在，创建新文件进行写入。|
|a+|打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于写。|
|ab+|以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。|

### 判断文件(夹)是否存在
1. 使用os模块
    * 判断文件(夹)是否存在
    ```
    import os
    os.path.exists(test_file.txt) # 或者传入一个文件
    ```
    >**这样就可能造成歧义**
    * 只判断文件是否存在
    ```
    import os
    os.path.isfile("test-data")
    ```

    * 判断文件是否可做操作
    使用os.access()方法判断文件是否可进行读写操作。
    ```
    os.access(path,mode)
    ```
    path为文件路径，mode为操作模式，有这么几种:
        * os.F_OK: 检查文件是否存在;
        * os.R_OK: 检查文件是否可读;
        * os.W_OK: 检查文件是否可以写入;
        * os.X_OK: 检查文件是否可以执行
2. 使用pathlib模块
    pathlib模块在Python3版本中是内建模块，但是在Python2中是需要单独安装三方模块。
    使用pathlib需要先使用文件路径来创建path对象。此路径可以是文件名或目录路径。
    * 检查路径是否存在
    ```
    path = pathlib.Path("path/file")
    path.exist()
    ```
    * 检查路径是否是文件
    ```
    path = pathlib.Path("path/file")
    path.is_file()
    ```

### 直接的文件操作(不引用库)

>**注意：**
**写二进制文件与写普通文件的区别就在开始open()时方式选择"wb"**
**写多行只是在每一行后面加一个"\n"**

```
fp = open("test.txt",w) #直接打开一个文件，如果文件不存在则创建文件
fp.read([size])               #size为读取的长度，以byte为单位
fp.readline([size])           #读一行，如果定义了size，有可能返回的只是一行的一部分
fp.readlines([size])          #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。
fp.write(str)                 #把str写到文件中，write()并不会在str后加上一个换行符
fp.writelines(seq)            #把seq的内容全部写到文件中,可以传入list的str,**结尾不会自己加换行**。
fp.close()                    #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。  如果一个文件在关闭后还对其进行操作会产生ValueError
fp.flush()                    #把缓冲区的内容写入硬盘
fp.fileno()                   #返回一个长整型的”文件标签“
fp.isatty()                   #文件是否是一个终端设备文件（unix系统中的）
fp.tell()                     #返回文件操作标记的当前位置，以文件的开头为原点
fp.next()                     #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。
fp.seek(offset[,whence])      #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。
fp.truncate([size])           #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。
```

### 直接的目录操作

```
创建目录 
os.mkdir("file")                   

复制文件
shutil.copyfile("oldfile","newfile")       oldfile和newfile都只能是文件 
shutil.copy("oldfile","newfile")            oldfile只能是文件夹，newfile可以是文件，也可以是目标目录

复制文件夹
shutil.copytree("olddir","newdir")        olddir和newdir都只能是目录，且newdir必须不存在

重命名文件（目录）
os.rename("oldname","newname")       文件或目录都是使用这条命令

移动文件（目录） 
shutil.move("oldpos","newpos")   

删除文件  
os.remove("file")

删除目录 
os.rmdir("dir")只能删除空目录 shutil.rmtree("dir")    空目录、有内容的目录都可以删

转换目录 
os.chdir("path")   换路径
```
